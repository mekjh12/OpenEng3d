#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
layout(rgba32f, binding = 0) uniform image3D outputTexture;

// 유니폼 변수들
uniform float time;
uniform vec3 resolution;
uniform float numCellsPerAxis;

// ===================================================================================
// Perlin 노이즈
// ===================================================================================
vec3 fade(vec3 t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

float grad(int hash, float x, float y, float z) {
    int h = hash & 15;
    float u = h < 8 ? x : y;
    float v = h < 4 ? y : h == 12 || h == 14 ? x : z;
    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
}

// 해시 함수
float hash(vec3 p) {
    p = fract(p * vec3(123.34, 234.34, 345.65));
    p += dot(p, p + 34.45);
    return fract(p.x * p.y * p.z);
}

int hashInt(vec3 p) {
    return int(hash(p) * 255.0);
}

// Perlin 노이즈 구현
float perlinNoise(vec3 p) {
    vec3 i = floor(p);
    vec3 f = fract(p);
    vec3 u = fade(f);
    
    return mix(mix(mix(grad(hashInt(i + vec3(0,0,0)), f.x, f.y, f.z),
                       grad(hashInt(i + vec3(1,0,0)), f.x-1.0, f.y, f.z), u.x),
                   mix(grad(hashInt(i + vec3(0,1,0)), f.x, f.y-1.0, f.z),
                       grad(hashInt(i + vec3(1,1,0)), f.x-1.0, f.y-1.0, f.z), u.x), u.y),
               mix(mix(grad(hashInt(i + vec3(0,0,1)), f.x, f.y, f.z-1.0),
                       grad(hashInt(i + vec3(1,0,1)), f.x-1.0, f.y, f.z-1.0), u.x),
                   mix(grad(hashInt(i + vec3(0,1,1)), f.x, f.y-1.0, f.z-1.0),
                       grad(hashInt(i + vec3(1,1,1)), f.x-1.0, f.y-1.0, f.z-1.0), u.x), u.y), u.z);
}

// Perlin FBM 생성 (Figure 4.5)
float perlinFBM(vec3 position, int octaves) {
    float value = 0.0;
    float amplitude = 1.0;
    float frequency = 1.0;
    float maxValue = 0.0;
    
    // 7 옥타브
    for(int i = 0; i < octaves; i++) {
        value += perlinNoise(position * frequency) * amplitude;
        maxValue += amplitude;
        
        amplitude *= 0.5;  // 각 옥타브마다 진폭 반감
        frequency *= 2.0;  // 각 옥타브마다 주파수 배증
    }
    
    return value / maxValue;
}

// ===================================================================================
// Worley 노이즈
// ===================================================================================
// 단일 Worley 노이즈 계산
float worleyNoise(vec3 position, float frequency) {
    vec3 scaledPos = position * frequency * numCellsPerAxis;
    float minDist = 1000.0; // 충분히 큰 값으로 초기화
    
    ivec3 cellIndex = ivec3(floor(scaledPos));
    
    for(int xOffset = -1; xOffset <= 1; xOffset++) {
        for(int yOffset = -1; yOffset <= 1; yOffset++) {
            for(int zOffset = -1; zOffset <= 1; zOffset++) {
                ivec3 neighborCell = cellIndex + ivec3(xOffset, yOffset, zOffset);
                
                // 타일링을 위한 래핑 (연속성 보장)
                vec3 wrappedCell = vec3(neighborCell);
                
                // 각 셀의 랜덤 포인트 생성 (해시 기반)
                vec3 cellHash = vec3(neighborCell) * 0.1031;
                cellHash = fract(cellHash * vec3(123.45, 234.56, 345.67));
                cellHash += dot(cellHash, cellHash.yzx + 19.19);
                vec3 point = wrappedCell + fract((cellHash.xxy + cellHash.yzz) * cellHash.zyx);
                
                // 타일링 경계 처리 - 여러 위치에서 거리 계산
                for(int wx = -1; wx <= 1; wx++) {
                    for(int wy = -1; wy <= 1; wy++) {
                        for(int wz = -1; wz <= 1; wz++) {
                            vec3 wrappedPoint = point + vec3(wx, wy, wz) * numCellsPerAxis;
                            float dist = length(scaledPos - wrappedPoint);
                            minDist = min(minDist, dist);
                        }
                    }
                }
            }
        }
    }
    
    // 정규화
    return minDist / (numCellsPerAxis * frequency);
}

// Worley FBM 생성 (파이썬 코드 참고)
float worleyFBM(vec3 position, int octaves) {
    float value = 0.0;
    float amplitude = 1.0;
    float frequency = 1.0;
    float maxValue = 0.0;
    
    for(int i = 0; i < octaves; i++) {
        value += worleyNoise(position, frequency) * amplitude;
        maxValue += amplitude;
        
        amplitude *= 0.5;  // persistence
        frequency *= 2.0;  // lacunarity
    }
    
    return value / maxValue;
}

// 리맵핑 함수
float remap(float value, float oldMin, float oldMax, float newMin, float newMax) {
    return newMin + ((value - oldMin) / (oldMax - oldMin)) * (newMax - newMin);
}

void main() 
{
    ivec3 texelCoord = ivec3(gl_GlobalInvocationID.xyz);
    
    if(texelCoord.x >= int(resolution.x) || texelCoord.y >= int(resolution.y) || texelCoord.z >= int(resolution.z)) {
        return;
    }
    
    vec3 position = vec3(texelCoord) / resolution;
    
    // Figure 4.8 생성 (논문의 방법에 따라)
    
    // R 채널: Perlin-Worley FBM (논문의 정확한 방법)
    float perlinBase = perlinFBM(position * 4.0, 1); // 기본 Perlin 노이즈
    perlinBase = (perlinBase + 1.0) * 0.5; // -1~1을 0~1로 변환
    
    float worleyFBMForMin = worleyFBM(position, 3); // 3 옥타브 Worley FBM
    worleyFBMForMin = clamp(1.0 - worleyFBMForMin, 0.0, 1.0); // 반전 및 정규화
    
    // 논문의 Perlin-Worley 공식 적용
    float perlinWorleyFBM = remap(perlinBase, worleyFBMForMin, 1.0, 0.0, 1.0);
    perlinWorleyFBM = clamp(perlinWorleyFBM, 0.0, 1.0);
    
    // G, B, A 채널: 개별 Worley 노이즈 옥타브들
    float worley1 = worleyNoise(position, 1.0);   // 낮은 주파수
    float worley2 = worleyNoise(position, 2.0);   // 중간 주파수  
    float worley3 = worleyNoise(position, 4.0);   // 높은 주파수
    
    // 0-1 범위로 정규화 및 반전
    float maxDist = sqrt(3.0) / numCellsPerAxis;
    worley1 = clamp(1.0 - worley1 / maxDist, 0.0, 1.0);
    worley2 = clamp(1.0 - worley2 / maxDist, 0.0, 1.0);
    worley3 = clamp(1.0 - worley3 / maxDist, 0.0, 1.0);
    
    // 결과를 RGBA 채널에 저장 (Figure 4.8)
    imageStore(outputTexture, texelCoord, vec4(
        perlinWorleyFBM,   // R: Perlin-Worley FBM (기본 구름 형태)
        worley1,           // G: Worley 옥타브 1 (낮은 주파수)
        worley2,           // B: Worley 옥타브 2 (중간 주파수)
        worley3            // A: Worley 옥타브 3 (높은 주파수)
    ));
}