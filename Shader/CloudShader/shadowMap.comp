#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// 입력 텍스처 (구름 밀도)
layout(binding = 0) uniform sampler3D cloudTexture;

// 출력 텍스처 (그림자 맵)
layout(binding = 0, r32f) uniform image3D shadowMap;

// 유니폼 변수
uniform vec3 lightDir;      // 광원 방향 (정규화된)
uniform vec3 resolution;    // 텍스처 크기
uniform float cloudDensity; // 구름 밀도 스케일

// Beer-Lambert 법칙 상수
const float STEP_SIZE = 0.01;
const int MAX_STEPS = 512;
const float DENSITY_THRESHOLD = 0.0001;

// 텍스처 좌표를 월드 좌표로 변환 (-0.5 ~ +0.5 범위)
vec3 texToWorld(vec3 texCoord) {
    return texCoord - 0.5;
}

// 월드 좌표를 텍스처 좌표로 변환 (0 ~ 1 범위)
vec3 worldToTex(vec3 worldPos) {
    return worldPos + 0.5;
}

// 구름 볼륨 내부인지 확인
bool isInVolume(vec3 pos) {
    return pos.x >= -0.5 && pos.x <= 0.5 && 
           pos.y >= -0.5 && pos.y <= 0.5 && 
           pos.z >= -0.5 && pos.z <= 0.5;
}

// 구름 밀도 샘플링
float sampleCloudDensity(vec3 worldPos) {
    vec3 texCoord = worldToTex(worldPos);
    if(texCoord.x < 0.0 || texCoord.x > 1.0 || 
       texCoord.y < 0.0 || texCoord.y > 1.0 || 
       texCoord.z < 0.0 || texCoord.z > 1.0) {
        return 0.0;
    }
    return texture(cloudTexture, texCoord).r * cloudDensity;
}

void main() {
    // 글로벌 작업 ID 가져오기
    ivec3 texelCoord = ivec3(gl_GlobalInvocationID.xyz);
    ivec3 texSize = ivec3(resolution);
    
    // 텍스처 경계 확인
    if(texelCoord.x >= texSize.x || texelCoord.y >= texSize.y || texelCoord.z >= texSize.z) {
        return;
    }
    
    // 텍스처 좌표 계산 (0-1 범위)
    vec3 texCoord = (vec3(texelCoord) + 0.5) / resolution;
    
    // 월드 좌표 계산 (-0.5 ~ +0.5 범위)
    vec3 worldPos = texToWorld(texCoord);
    
    // 광원 방향을 따라 레이마칭
    vec3 stepVec = normalize(lightDir) * STEP_SIZE;
    vec3 currentPos = worldPos;
    float transmittance = 1.0;
    
    // 광원 방향으로 레이마칭 시작
    for(int i = 0; i < MAX_STEPS; i++) {
        // 다음 위치로 이동
        currentPos += stepVec;
        
        // 볼륨을 벗어났는지 확인
        if(!isInVolume(currentPos)) {
            break;
        }
        
        // 구름 밀도 샘플링
        float density = sampleCloudDensity(currentPos);
        
        // 밀도가 임계값보다 높으면 감쇠 계산
        if(density > DENSITY_THRESHOLD) {
            // Beer-Lambert 법칙 적용
            float absorption = exp(-density * STEP_SIZE);
            transmittance *= absorption;
            
            // 거의 완전히 감쇠되면 최적화를 위해 중단
            if(transmittance < 0.01) {
                transmittance = 0.01; // 최소값 설정
                break;
            }
        }
    }
    
    // 결과 투과율을 그림자 맵에 저장 (R 채널)
    imageStore(shadowMap, texelCoord, vec4(transmittance, 0.0, 0.0, 0.0));
}