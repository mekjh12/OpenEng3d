#version 430 core

// 워크그룹 크기: 16x16
layout(local_size_x = 16, local_size_y = 16) in;

// 입출력 이미지
layout(binding = 0, rgba16f) readonly uniform image2D skyTexture;  // 입력 하늘 텍스처
layout(binding = 1, rgba16f) writeonly uniform image2D cloudTexture; // 출력 구름 텍스처

// 노이즈 텍스처
layout(binding = 2) uniform sampler3D noiseTexture;        // 주 노이즈 텍스처
layout(binding = 3) uniform sampler3D detailNoiseTexture;  // 디테일 노이즈 텍스처

// 태양 관련 유니폼
uniform vec3 sunDirection;   // 태양 방향 (정규화된 벡터)
uniform vec3 sunColor;       // 태양 색상

// 카메라/관찰자 관련 유니폼
uniform vec3 cameraPosition; // 카메라 위치
uniform float nearPlane;     // 카메라 가까운 평면
uniform float farPlane;      // 카메라 먼 평면

// 구름 형상 관련 유니폼
uniform float cloudLayerBottom; // 구름층 하단 고도 (미터)
uniform float cloudLayerTop;    // 구름층 상단 고도 (미터)
uniform float cloudCoverage;    // 구름 커버리지 (0.0-1.0)
uniform float cloudDensity;     // 구름 밀도 계수
uniform float cloudSharpness;   // 구름 선명도
uniform float cloudDetailStrength; // 구름 디테일 강도

// 구름 애니메이션 관련 유니폼
uniform vec3 cloudOffset;    // 구름 오프셋 (애니메이션용)
uniform float time;          // 시간

// 레이트레이싱 관련 유니폼
uniform int primaryStepCount;  // 주 레이마칭 단계 수
uniform int lightStepCount;    // 광선 샘플링 단계 수
uniform float primaryStepSize; // 주 레이마칭 단계 크기
uniform float lightStepSize;   // 광선 샘플링 단계 크기

// 상수
const float PI = 3.14159265359;
const float EPSILON = 0.0001;
const float MAX_DISTANCE = 100000.0; // 최대 레이 거리

// 워핑된 FBM(Fractal Brownian Motion) 노이즈 함수
float worleyFbm(vec3 pos, float persistence, int octaves) {
    float noise = 0.0;
    float amplitude = 1.0;
    float frequency = 1.0;
    float total_amplitude = 0.0;
    
    for (int i = 0; i < octaves; i++) {
        // 워핑된 위치에서 노이즈 샘플링
        float n = 1.0 - texture(noiseTexture, pos * frequency).r;
        noise += n * amplitude;
        total_amplitude += amplitude;
        
        amplitude *= persistence;
        frequency *= 2.0;
    }
    
    return noise / total_amplitude;
}

// 구름 모양 함수 - 형상과 디테일을 혼합
float cloudShape(vec3 pos, float coverage) {
    // 원래 좌표에 오프셋 적용
    vec3 p = pos + cloudOffset;
    
    // 저주파 노이즈 (구름의 기본 형태)
    float baseNoise = worleyFbm(p * 0.0001, 0.5, 4);
    
    // 커버리지 기반 임계값 적용 (형태 정의)
    float coverageThreshold = 1.0 - coverage;
    float baseCloud = max(0.0, baseNoise - coverageThreshold) / (1.0 - coverageThreshold);
    
    // 구름 형태 선명도 적용
    baseCloud = pow(baseCloud, cloudSharpness);
    
    // 디테일 노이즈가 없거나 가장자리가 아니면 기본 형태만 반환
    if (cloudDetailStrength <= 0.0 || baseCloud <= 0.0 || baseCloud >= 1.0) {
        return baseCloud;
    }
    
    // 고주파 노이즈 (디테일)
    float detailNoise = worleyFbm(p * 0.001, 0.7, 2);
    
    // 디테일 노이즈 적용 (가장자리에서 더 강하게)
    float edgeFactor = (1.0 - baseCloud) * baseCloud * 4.0; // 가장자리 가중치
    float detailModifier = mix(1.0, (1.0 - detailNoise), edgeFactor * cloudDetailStrength);
    
    // 최종 구름 밀도
    return baseCloud * detailModifier;
}

// 고도 기반 밀도 변화 함수
float heightBasedDensity(float height, float bottomHeight, float topHeight) {
    // 정규화된 고도 (0 = 하단, 1 = 상단)
    float normalizedHeight = (height - bottomHeight) / (topHeight - bottomHeight);
    normalizedHeight = clamp(normalizedHeight, 0.0, 1.0);
    
    // 고도에 따른 밀도 변화 (하단에서 중간까지 증가, 중간에서 상단까지 감소)
    float densityFactor = 4.0 * normalizedHeight * (1.0 - normalizedHeight);
    return densityFactor;
}

// 구름 샘플링 함수
float sampleCloud(vec3 position, float coverage) {
    // 고도 계산 (평면 지표면 가정, z가 하늘 방향)
    float altitude = position.z;
    
    // 구름층 범위 밖이면 0 반환
    if (altitude < cloudLayerBottom || altitude > cloudLayerTop) {
        return 0.0;
    }
    
    // 구름 형태 샘플링
    float cloudSample = cloudShape(position, coverage);
    
    // 고도 기반 밀도 조정
    float heightFactor = heightBasedDensity(altitude, cloudLayerBottom, cloudLayerTop);
    
    // 최종 구름 밀도
    return cloudSample * heightFactor * cloudDensity;
}

// 레이-평면 교차 계산 (고도 기반)
bool rayPlaneIntersection(vec3 rayOrigin, vec3 rayDir, float planeHeight, out float t) {
    // 수평면(z = planeHeight)과의 교차 계산
    if (abs(rayDir.z) < EPSILON) {
        // 레이가 평면과 거의 평행함
        return false;
    }
    
    t = (planeHeight - rayOrigin.z) / rayDir.z;
    return t > 0.0; // 양의 교차점만 유효
}

// 베어-랑버트 산란 함수 (기본 HG 함수의 단순화된 버전)
float phaseFunction(float cosTheta) {
    return (1.0 + cosTheta) * 0.5;
}

// 구름에서의 광 산란 계산
vec3 calculateLightScattering(vec3 position, float density) {
    if (density <= 0.0) {
        return vec3(0.0);
    }
    
    // 광원(태양) 방향으로의 감쇠 계산
    float transmittance = 1.0;
    vec3 sunDirPos = position;
    float stepSize = lightStepSize;
    
    for (int i = 0; i < lightStepCount; i++) {
        sunDirPos += sunDirection * stepSize;
        
        // 구름 샘플링
        float sunDirDensity = sampleCloud(sunDirPos, cloudCoverage);
        
        // 투과율 갱신
        transmittance *= exp(-sunDirDensity * stepSize * 0.1);
        
        // 충분히 감쇠되면 일찍 종료
        if (transmittance < 0.01) {
            transmittance = 0.0;
            break;
        }
    }
    
    // 산란 효과 (Powder Sugar Effect)
    float powderEffect = 1.0 - exp(-density * 2.0);
    
    // 빛 에너지: 투과율 * 광원 색상 * 위상 함수 * 산란 효과
    vec3 lightEnergy = transmittance * sunColor * phaseFunction(dot(normalize(cameraPosition - position), sunDirection)) * powderEffect;
    
    return lightEnergy;
}

// 주 레이마칭 함수
vec4 raymarchCloud(vec3 rayOrigin, vec3 rayDir) {
    // 구름층 하단과의 교차점
    float tBottom;
    bool hitBottom = rayPlaneIntersection(rayOrigin, rayDir, cloudLayerBottom, tBottom);
    
    // 구름층 상단과의 교차점
    float tTop;
    bool hitTop = rayPlaneIntersection(rayOrigin, rayDir, cloudLayerTop, tTop);
    
    // 교차점이 없거나 레이가 아래로 향하면서 카메라가 구름층 위에 있는 경우
    if ((!hitBottom && !hitTop) || (rayDir.z < 0.0 && rayOrigin.z > cloudLayerTop)) {
        return vec4(0.0);
    }
    
    // 시작 및 종료 지점 계산
    float tStart, tEnd;
    
    if (rayOrigin.z < cloudLayerBottom) {
        // 카메라가 구름층 아래에 있는 경우
        tStart = hitBottom ? tBottom : 0.0;
        tEnd = hitTop ? tTop : MAX_DISTANCE;
    } else if (rayOrigin.z > cloudLayerTop) {
        // 카메라가 구름층 위에 있는 경우
        tStart = hitTop ? tTop : 0.0;
        tEnd = hitBottom ? tBottom : MAX_DISTANCE;
    } else {
        // 카메라가 구름층 내부에 있는 경우
        tStart = 0.0; // 현재 위치에서 시작
        tEnd = (rayDir.z > 0.0) ? (hitTop ? tTop : MAX_DISTANCE) : (hitBottom ? tBottom : MAX_DISTANCE);
    }
    
    // 유효한 범위 검사
    if (tStart >= tEnd || tEnd <= 0.0) {
        return vec4(0.0);
    }
    
    // 레이마칭 초기화
    float transmittance = 1.0;
    vec3 lightAccumulation = vec3(0.0);
    float stepSize = primaryStepSize;
    float t = tStart;
    
    // 적응형 스텝 사이즈를 위한 변수들
    float previousDensity = 0.0;
    
    // 레이마칭 루프
    for (int i = 0; i < primaryStepCount && t < tEnd; i++) {
        // 현재 위치
        vec3 pos = rayOrigin + rayDir * t;
        
        // 구름 밀도 샘플링
        float density = sampleCloud(pos, cloudCoverage);
        
        // 밀도가 있는 경우 산란 계산
        if (density > 0.0) {
            // 단계별 투과율 (Beer-Lambert 법칙)
            float stepTransmittance = exp(-density * stepSize * 0.1);
            
            // 현재 단계의 산란광
            vec3 stepScattering = calculateLightScattering(pos, density);
            
            // 산란광 누적 (현재 투과율로 가중치 부여)
            lightAccumulation += stepScattering * (1.0 - stepTransmittance) * transmittance;
            
            // 전체 투과율 갱신
            transmittance *= stepTransmittance;
            
            // 투과율이 매우 낮으면 일찍 종료
            if (transmittance < 0.01) {
                transmittance = 0.0;
                break;
            }
            
            // 밀도 변화에 따른 스텝 사이즈 조정 (높은 밀도 구역에서 더 작은 스텝)
            if (i > 0) {
                float densityChange = abs(density - previousDensity);
                stepSize = mix(stepSize * 1.5, stepSize * 0.5, min(1.0, densityChange * 10.0));
                stepSize = clamp(stepSize, primaryStepSize * 0.25, primaryStepSize * 2.0);
            }
            
            previousDensity = density;
        } else {
            // 빈 공간에서는 더 큰 스텝
            stepSize = primaryStepSize * 1.5;
        }
        
        // 다음 단계로 이동
        t += stepSize;
    }
    
    // 최종 색상 및 투명도 반환
    return vec4(lightAccumulation, 1.0 - transmittance);
}

// 스크린 좌표로부터 월드 좌표계의 레이 방향 계산
vec3 getWorldRayDir(ivec2 pixelCoords, ivec2 screenSize) {
    // 정규화된 장치 좌표계 (NDC)
    vec2 uv = (vec2(pixelCoords) + 0.5) / vec2(screenSize);
    vec2 ndc = 2.0 * uv - 1.0;
    
    // Z가 하늘 방향인 좌표계에 맞추어 조정
    // X는 오른쪽, Y는 앞쪽, Z는 위쪽을 향함
    vec3 rayDir = normalize(vec3(ndc.x, -1.0, ndc.y));
    
    return rayDir;
}

// 메인 컴퓨트 셰이더 코드
void main() {
    // 현재 픽셀 좌표
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    
    // 텍스처 크기
    ivec2 textureSize = imageSize(skyTexture);
    
    // 범위 체크
    if (pixelCoords.x >= textureSize.x || pixelCoords.y >= textureSize.y) {
        return;
    }
    
    // 현재 하늘 색상 가져오기
    vec4 skyColor = imageLoad(skyTexture, pixelCoords);
    
    // 레이 방향 계산
    vec3 rayDir = getWorldRayDir(pixelCoords, textureSize);
    
    // 구름 레이마칭
    vec4 cloudColor = raymarchCloud(cameraPosition, rayDir);
    
    // 하늘색과 구름색 합성
    vec4 finalColor = vec4(
        mix(skyColor.rgb, cloudColor.rgb, cloudColor.a),
        max(skyColor.a, cloudColor.a)
    );
    
    // 결과 저장
    imageStore(cloudTexture, pixelCoords, finalColor);
}